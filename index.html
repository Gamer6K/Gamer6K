<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Data Drifter</title>
  <style>
    /* ===================== CSS VARIABLES & GLOBAL STYLES ===================== */
    :root {
      --bg-primary: #0a0a1a;
      --bg-secondary: #18182f;
      --bg-accent: #2d2d4d;
      --accent-color: #00eaff;
      --accent-color-dark: #009bbf;
      --text-color: #e0e0ff;
      --grid-line: rgba(0, 234, 255, 0.05);
      --shadow-glow: rgba(0, 234, 255, 0.6);
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(
        135deg,
        var(--bg-primary) 0%,
        var(--bg-secondary) 50%,
        var(--bg-accent) 100%
      );
      font-family: 'Courier New', monospace;
      color: var(--text-color);
      overflow: hidden;
    }
    
    /* ===================== MAIN MENU ===================== */
    #main-menu {
      display: block;
      text-align: center;
      background: rgba(10, 10, 26, 0.95);
      padding: 3rem;
      border-radius: 15px;
      border: 3px solid var(--accent-color);
      box-shadow: 
        0 0 40px var(--shadow-glow),
        inset 0 0 25px rgba(0, 234, 255, 0.4);
      backdrop-filter: blur(10px);
      animation: fadeIn 0.5s ease-out;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #main-menu h1 {
      font-size: 4rem;
      color: var(--accent-color);
      margin-bottom: 1.5rem;
      letter-spacing: 6px;
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
    }
    #main-menu button {
      display: block;
      margin: 1.2rem auto;
      padding: 0.8rem 1.5rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      width: 200px;
      transition: all 0.3s ease;
    }
    #main-menu button:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 20px var(--shadow-glow), inset 0 0 15px rgba(0, 234, 255, 0.5);
    }
    
    /* ===================== MODE SELECTION MENU ===================== */
    #mode-menu {
      display: none;
      text-align: center;
      background: rgba(10, 10, 26, 0.95);
      padding: 3rem;
      border-radius: 15px;
      border: 3px solid var(--accent-color);
      box-shadow: 
        0 0 40px var(--shadow-glow),
        inset 0 0 25px rgba(0, 234, 255, 0.4);
      backdrop-filter: blur(10px);
      animation: fadeIn 0.5s ease-out;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #mode-menu h2 {
      font-size: 2.5rem;
      color: var(--accent-color);
      margin-bottom: 1.5rem;
      letter-spacing: 4px;
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
    }
    #mode-menu button {
      display: block;
      margin: 1.2rem auto;
      padding: 0.7rem 1.5rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      width: 220px;
      transition: all 0.3s ease;
    }
    #mode-menu button:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 25px var(--shadow-glow);
    }
    
    /* ===================== SETTINGS MENU ===================== */
    #settings-menu {
      display: none;
      text-align: center;
      background: rgba(10, 10, 26, 0.95);
      padding: 3rem;
      border-radius: 15px;
      border: 3px solid var(--accent-color);
      box-shadow: 
        0 0 40px var(--shadow-glow),
        inset 0 0 25px rgba(0, 234, 255, 0.4);
      backdrop-filter: blur(10px);
      animation: fadeIn 0.5s ease-out;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
    }
    #settings-menu h2 {
      font-size: 2.5rem;
      color: var(--accent-color);
      margin-bottom: 1.5rem;
      letter-spacing: 4px;
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
    }
    #settings-menu button {
      display: block;
      margin: 1.2rem auto;
      padding: 0.7rem 1.5rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      width: 150px;
      transition: all 0.3s ease;
    }
    #settings-menu button:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 25px var(--shadow-glow);
    }
    
    /* ===================== SCORE BOARD ===================== */
    #score-board {
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent-color);
      margin: 25px 0;
      text-align: center;
      letter-spacing: 3px;
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
    }
    
    /* ===================== GAME AREA ===================== */
    #game-container {
      position: relative;
      padding: 0;
      background: var(--bg-primary);
      border-radius: 12px;
      border: 3px solid var(--accent-color);
      box-shadow: 
        0 0 50px rgba(0, 0, 0, 0.5),
        inset 0 0 30px rgba(0, 234, 255, 0.2);
      display: none;
      width: fit-content;
      margin: 0 auto;
    }
    #game-canvas {
      background: linear-gradient(90deg, var(--grid-line) 1px, transparent 1px) 0 0 / 50px 50px,
                  linear-gradient(0deg, var(--grid-line) 1px, transparent 1px) 0 0 / 50px 50px,
                  var(--bg-primary);
      border-radius: 12px;
      box-shadow: 0 0 30px var(--shadow-glow), inset 0 0 20px rgba(0, 234, 255, 0.3);
    }
    
    /* ===================== PAUSE BUTTON STYLING ===================== */
    #pause-btn {
      position: absolute;
      top: -65px;
      right: 0px;
      z-index: 999;
      margin: 0;
      padding: 0.7rem 1.5rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      transition: all 0.3s ease;
    }
    #pause-btn:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 20px var(--shadow-glow), inset 0 0 15px rgba(0, 234, 255, 0.5);
    }
    
    /* ===================== START MENU, PAUSE & GAME OVER ===================== */
    #start-menu,
    #pause-message,
    #game-over-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 26, 0.95);
      padding: 3rem;
      border-radius: 15px;
      text-align: center;
      border: 3px solid var(--accent-color);
      box-shadow: 
        0 0 40px var(--shadow-glow),
        inset 0 0 25px rgba(0, 234, 255, 0.4);
      backdrop-filter: blur(12px);
      animation: fadeIn 0.5s ease-out;
    }
    #start-menu { display: block; }
    #pause-message,
    #game-over-message { display: none; }
    
    #start-menu h2,
    #pause-message h2,
    #game-over-message h2 {
      color: var(--accent-color);
      font-size: 3rem;
      margin: 0 0 1.5rem 0;
      letter-spacing: 5px;
      text-shadow: 0 0 20px var(--shadow-glow);
    }
    #start-menu p,
    #pause-message p,
    #game-over-message p {
      font-size: 1.4rem;
      margin: 1.2rem 0;
      color: var(--text-color);
    }
    #start-menu p.instructions {
      font-size: 1.2rem;
      margin: 0.7rem 0 1.2rem 0;
    }
    #start-button,
    .key {
      padding: 0.6rem 1.2rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      margin: 1.2rem auto 0 auto;
      color: var(--accent-color);
      font-size: 1.1rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      display: inline-block;
      transition: all 0.3s ease;
    }
    .key {
      margin: 0 0.4rem;
      padding: 0.3rem 0.8rem;
      font-size: 1.1rem;
      box-shadow: 0 0 12px var(--shadow-glow);
    }
    #start-button:hover,
    .key:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 20px var(--shadow-glow), inset 0 0 15px rgba(0, 234, 255, 0.5);
    }
    #pause-menu-buttons {
      margin-top: 1.8rem;
    }
    #pause-menu-buttons button {
      margin: 0.5rem;
      padding: 0.7rem 1.5rem;
      background: rgba(0, 234, 255, 0.15);
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 0 15px var(--shadow-glow), inset 0 0 10px rgba(0, 234, 255, 0.3);
      transition: all 0.3s ease;
    }
    #pause-menu-buttons button:hover {
      background: var(--accent-color);
      transform: scale(1.1);
      color: #000000;
      box-shadow: 0 0 25px var(--shadow-glow), inset 0 0 15px rgba(0, 234, 255, 0.5);
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -45%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }
  </style>
</head>
<body>
  <!-- ===================== MAIN MENU ===================== -->
  <div id="main-menu">
    <h1>SNAKE GAME</h1>
    <button id="play-game-btn">Play Game</button>
    <button id="settings-btn">Settings</button>
  </div>
  
  <!-- ===================== MODE SELECTION MENU ===================== -->
  <div id="mode-menu">
    <h2>Select Mode</h2>
    <button id="classic-mode-btn">Classic Mode</button>
  </div>
  
  <!-- ===================== SETTINGS MENU ===================== -->
  <div id="settings-menu">
    <h2>Settings</h2>
    <p>Volume, difficulty, etc. (Not implemented yet!)</p>
    <button id="back-btn">Back</button>
  </div>
  
  <!-- ===================== GAME AREA ===================== -->
  <div id="score-board">Score: 0</div>
  <div id="game-container">
    <button id="pause-btn">Pause</button>
    <canvas id="game-canvas"></canvas>
    
    <!-- ===================== START MENU ===================== -->
    <div id="start-menu">
      <h2>START GAME</h2>
      <p>Press <span class="key">ENTER</span> or click below to start</p>
      <p class="instructions">Use W,A,S,D or Arrow Keys for Movements</p>
      <p>Press <span class="key">Space</span> to Pause</p>
      <button id="start-button">START</button>
    </div>
    
    <!-- ===================== PAUSE MESSAGE ===================== -->
    <div id="pause-message">
      <h2>PAUSED</h2>
      <p>Press <span class="key">SPACE</span> to resume</p>
      <div id="pause-menu-buttons">
        <button id="resume-btn">Resume</button>
        <button id="pause-settings-btn">Settings</button>
        <button id="pause-main-menu-btn">Main Menu</button>
      </div>
    </div>
    
    <!-- ===================== GAME OVER MESSAGE ===================== -->
    <div id="game-over-message">
      <h2>GAME OVER</h2>
      <p>Score: <span id="finalScore">0</span></p>
      <p>Press <span class="key">ENTER</span> or <span class="key">SPACE</span> to restart</p>
    </div>
  </div>
  
  <script>
    /***** CONFIGURABLE CONSTANTS *****/
    const TILE_COUNT_X = 15;
    const TILE_COUNT_Y = 13;
    const GRID_SIZE = 50;
    const BOARD_WIDTH = TILE_COUNT_X * GRID_SIZE;
    const BOARD_HEIGHT = TILE_COUNT_Y * GRID_SIZE;
    
    const APPLE_RADIUS = 18;
    const SNAKE_BODY_RADIUS = 18;
    const SNAKE_HEAD_RADIUS = 18;
    
    const START_SPEED = 120;
    const SPEED_STEP = 2;
    const MIN_SPEED = 50;
    const SCORE_VALUE = 10;
    
    const PACKET_SIZE = 30;
    const STREAM_WIDTH = 40;
    let glitchTime = 0;
    
    // Global variable to track the origin of the settings popup ("main" or "pause")
    let settingsOrigin = "";
    
    /***** CANVAS SETUP *****/
    const canvas = document.getElementById('game-canvas');
    canvas.width = BOARD_WIDTH;
    canvas.height = BOARD_HEIGHT;
    canvas.style.background = `
      linear-gradient(90deg, var(--grid-line) 1px, transparent 1px) 0 0 / ${GRID_SIZE}px ${GRID_SIZE}px,
      linear-gradient(0deg, var(--grid-line) 1px, transparent 1px) 0 0 / ${GRID_SIZE}px ${GRID_SIZE}px,
      var(--bg-primary)
    `;
    
    /***** GLOBAL GAME STATE VARIABLES *****/
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('score-board');
    const pauseMessage = document.getElementById('pause-message');
    const gameOverMessage = document.getElementById('game-over-message');
    
    let snake = [];
    let prevSnake = [];
    let food = {};
    let dx = GRID_SIZE;
    let dy = 0;
    let nextDir = { x: dx, y: dy };
    let score = 0;
    let gameSpeed = START_SPEED;
    let isPaused = false;
    let isGameOver = false;
    let lastUpdateTime = performance.now();
    let accumulatedTime = 0;
    
    let gameMode = "classic";
    let gameStarted = false;
    
    /***** GAME INITIALIZATION *****/
    function initGame() {
      snake = [
        { x: 4 * GRID_SIZE, y: 4 * GRID_SIZE },
        { x: 3 * GRID_SIZE, y: 4 * GRID_SIZE }
      ];
      prevSnake = snake.map(seg => ({ ...seg }));
      dx = GRID_SIZE;
      dy = 0;
      nextDir = { x: dx, y: dy };
      score = 0;
      gameSpeed = START_SPEED;
      isPaused = false;
      isGameOver = false;
      scoreBoard.textContent = `Score: ${score}`;
      pauseMessage.style.display = 'none';
      gameOverMessage.style.display = 'none';
      spawnFood();
      lastUpdateTime = performance.now();
      accumulatedTime = 0;
    }
    
    /***** FOOD SPAWNING LOGIC *****/
    function spawnFood() {
      while (true) {
        const xCell = Math.floor(Math.random() * TILE_COUNT_X);
        const yCell = Math.floor(Math.random() * TILE_COUNT_Y);
        if ((xCell === 0 || xCell === TILE_COUNT_X - 1 || yCell === 0 || yCell === TILE_COUNT_Y - 1) && Math.random() > 0.2) {
          continue;
        }
        const x = xCell * GRID_SIZE;
        const y = yCell * GRID_SIZE;
        if (!snake.some(seg => seg.x === x && seg.y === y)) {
          food = { x, y };
          break;
        }
      }
    }
    
    /***** DRAWING FUNCTIONS *****/
    function drawPacket() {
      const centerX = food.x + GRID_SIZE / 2;
      const centerY = food.y + GRID_SIZE / 2;
      const size = PACKET_SIZE;
    
      ctx.save();
      ctx.shadowColor = 'rgba(0, 234, 255, 0.9)';
      ctx.shadowBlur = 30;
      const gradient = ctx.createLinearGradient(
        centerX - size / 2, centerY - size / 2,
        centerX + size / 2, centerY + size / 2
      );
      gradient.addColorStop(0, '#00eaff');
      gradient.addColorStop(0.2, '#00c0ff');
      gradient.addColorStop(0.5, '#009bbf');
      gradient.addColorStop(0.8, '#0077b3');
      gradient.addColorStop(1, '#003366');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(centerX - size / 2, centerY - size / 2);
      ctx.lineTo(centerX + size / 2, centerY - size / 2);
      ctx.lineTo(centerX + size / 2, centerY + size / 2);
      ctx.lineTo(centerX - size / 2, centerY + size / 2);
      ctx.closePath();
      ctx.fill();
    
      ctx.fillStyle = 'rgba(0, 51, 102, 0.7)';
      ctx.beginPath();
      ctx.moveTo(centerX + size / 2, centerY - size / 2);
      ctx.lineTo(centerX + size / 2 + 10, centerY - size / 2 + 5);
      ctx.lineTo(centerX + size / 2 + 10, centerY + size / 2 + 5);
      ctx.lineTo(centerX + size / 2, centerY + size / 2);
      ctx.closePath();
      ctx.fill();
    
      ctx.beginPath();
      ctx.moveTo(centerX - size / 2, centerY - size / 2);
      ctx.lineTo(centerX - size / 2 - 10, centerY - size / 2 + 5);
      ctx.lineTo(centerX - size / 2 - 10, centerY + size / 2 + 5);
      ctx.lineTo(centerX - size / 2, centerY + size / 2);
      ctx.closePath();
      ctx.fill();
    
      ctx.strokeStyle = 'rgba(0, 234, 255, 0.8)';
      ctx.lineWidth = 3;
      ctx.strokeRect(centerX - size / 2, centerY - size / 2, size, size);
    
      ctx.fillStyle = 'rgba(0, 234, 255, 0.5)';
      for (let i = 0; i < 8; i++) {
        const angle = (2 * Math.PI * i) / 8;
        const radius = size / 2 + Math.random() * 15;
        const particleSize = Math.random() * 4 + 2;
        ctx.beginPath();
        ctx.arc(
          centerX + Math.cos(angle) * radius,
          centerY + Math.sin(angle) * radius,
          particleSize, 0, 2 * Math.PI
        );
        ctx.fill();
      }
      ctx.font = '22px monospace';
      const glitchSpeed = 0.15;
      glitchTime += glitchSpeed;
      for (let i = 0; i < 4; i++) {
        const xPos = centerX - 12 + (i % 2 === 0 ? -10 : 10);
        const yPos = centerY - 12 + (i > 1 ? 10 : -10);
        const xOffset = Math.sin(glitchTime + i * 0.5) * 3;
        const yOffset = Math.cos(glitchTime + i * 0.6) * 3;
        const digit = Math.random() > 0.5 ? '1' : '0';
        const opacity = Math.random() > 0.2 ? 0.9 : 0.4;
        const color = Math.random() > 0.9 ? '#ff5555' : '#ffffff';
        ctx.fillStyle = `rgba(${hexToRgb(color).r}, ${hexToRgb(color).g}, ${hexToRgb(color).b}, ${opacity})`;
        ctx.fillText(digit, xPos + xOffset, yPos + yOffset);
      }
    
      ctx.restore();
    }
    
    function drawDataStream(segments) {
      if (segments.length < 2) return;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(segments[0].x, segments[0].y);
      for (let i = 1; i < segments.length - 2; i++) {
        const xc = (segments[i].x + segments[i + 1].x) / 2;
        const yc = (segments[i].y + segments[i + 1].y) / 2;
        ctx.quadraticCurveTo(segments[i].x, segments[i].y, xc, yc);
      }
      ctx.quadraticCurveTo(
        segments[segments.length - 2].x,
        segments[segments.length - 2].y,
        segments[segments.length - 1].x,
        segments[segments.length - 1].y
      );
      const gradient = ctx.createLinearGradient(
        segments[0].x, segments[0].y,
        segments[segments.length - 1].x, segments[segments.length - 1].y
      );
      gradient.addColorStop(0, '#1e90ff');
      gradient.addColorStop(0.3, '#4169e1');
      gradient.addColorStop(0.6, '#00c0ff');
      gradient.addColorStop(1, '#00eaff');
      ctx.lineWidth = STREAM_WIDTH;
      ctx.strokeStyle = gradient;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = 'rgba(0, 234, 255, 0.8)';
      ctx.shadowBlur = 30;
      ctx.stroke();
    
      ctx.fillStyle = 'rgba(0, 234, 255, 0.6)';
      for (let i = 0; i < segments.length; i += 2) {
        const seg = segments[i];
        for (let j = 0; j < 3; j++) {
          const angle = Math.random() * 2 * Math.PI;
          const radius = Math.random() * 15;
          ctx.beginPath();
          ctx.arc(
            seg.x + Math.cos(angle) * radius,
            seg.y + Math.sin(angle) * radius,
            3, 0, 2 * Math.PI
          );
          ctx.fill();
        }
      }
    
      ctx.font = '20px monospace';
      const glitchSpeed = 0.2;
      glitchTime += glitchSpeed;
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const xOffset = Math.sin(glitchTime + i * 0.3) * 8;
        const yOffset = Math.cos(glitchTime + i * 0.4) * 8;
        const digit = Math.random() > 0.5 ? '1' : '0';
        const opacity = Math.random() > 0.2 ? 0.9 : 0.4;
        const color = Math.random() > 0.9 ? '#ff5555' : '#ffffff';
        ctx.fillStyle = `rgba(${hexToRgb(color).r}, ${hexToRgb(color).g}, ${hexToRgb(color).b}, ${opacity})`;
        ctx.fillText(digit, seg.x - 10 + xOffset, seg.y + 10 + yOffset);
      }
      ctx.restore();
    }
    
    function drawStreamHead(segment) {
      const angle = Math.atan2(dy, dx);
      const centerX = segment.x;
      const centerY = segment.y;
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      const headGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, STREAM_WIDTH * 0.8);
      headGrad.addColorStop(0, '#00eaff');
      headGrad.addColorStop(0.4, '#00c0ff');
      headGrad.addColorStop(0.7, '#4169e1');
      headGrad.addColorStop(1, '#1e90ff');
      ctx.shadowColor = 'rgba(0, 234, 255, 0.9)';
      ctx.shadowBlur = 35;
      ctx.beginPath();
      ctx.arc(0, 0, STREAM_WIDTH * 0.8, 0, 2 * Math.PI);
      ctx.fillStyle = headGrad;
      ctx.fill();
      const time = Date.now() * 0.005;
      const pulseRadius = STREAM_WIDTH * 0.8 + Math.sin(time) * 10;
      ctx.strokeStyle = 'rgba(0, 234, 255, 0.7)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, pulseRadius, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fillStyle = '#1e90ff';
      ctx.beginPath();
      ctx.moveTo(STREAM_WIDTH * 0.8, 0);
      ctx.lineTo(STREAM_WIDTH * 1.2, -10);
      ctx.lineTo(STREAM_WIDTH * 1.2, 10);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(0, 234, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = '24px monospace';
      const headDigit = Math.random() > 0.5 ? '1' : '0';
      const headOpacity = Math.random() > 0.3 ? 0.9 : 0.4;
      ctx.fillStyle = `rgba(255, 255, 255, ${headOpacity})`;
      ctx.fillText(headDigit, STREAM_WIDTH * 0.6, 5);
      ctx.restore();
    }
    
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 255, g: 255, b: 255 };
    }
    
    function draw(interp = 1) {
      ctx.clearRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
      const smoothInterp = interp * interp * (3 - 2 * interp);
      const interpSnake = snake.map((seg, i) => {
        const prev = prevSnake[i] || seg;
        return {
          x: prev.x + (seg.x - prev.x) * smoothInterp + GRID_SIZE / 2,
          y: prev.y + (seg.y - prev.y) * smoothInterp + GRID_SIZE / 2
        };
      });
      drawDataStream(interpSnake);
      drawStreamHead(interpSnake[0]);
      drawPacket();
    }
    
    function updateGameLogic() {
      dx = nextDir.x;
      dy = nextDir.y;
      prevSnake = snake.map(seg => ({ ...seg }));
      const head = { x: snake[0].x + dx, y: snake[0].y + dy };
      if (head.x < 0 || head.x >= BOARD_WIDTH || head.y < 0 || head.y >= BOARD_HEIGHT) {
        gameOver();
        return;
      }
      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver();
        return;
      }
      snake.unshift(head);
      if (head.x === food.x && head.y === food.y) {
        score += SCORE_VALUE;
        scoreBoard.textContent = `Score: ${score}`;
        spawnFood();
        gameSpeed = Math.max(MIN_SPEED, gameSpeed - SPEED_STEP);
      } else {
        snake.pop();
      }
    }
    
    function gameLoop(timestamp) {
      if (isPaused || isGameOver) {
        lastUpdateTime = timestamp;
        draw(accumulatedTime / gameSpeed);
        requestAnimationFrame(gameLoop);
        return;
      }
      const delta = timestamp - lastUpdateTime;
      lastUpdateTime = timestamp;
      accumulatedTime += delta;
      while (accumulatedTime >= gameSpeed) {
        updateGameLogic();
        accumulatedTime -= gameSpeed;
      }
      const interp = accumulatedTime / gameSpeed;
      draw(interp);
      requestAnimationFrame(gameLoop);
    }
    
    function gameOver() {
      isGameOver = true;
      gameOverMessage.style.display = 'block';
      document.getElementById('finalScore').textContent = score;
    }
    
    function togglePause() {
      if (isGameOver) return;
      isPaused = !isPaused;
      pauseMessage.style.display = isPaused ? 'block' : 'none';
    }
    
    function startGame() {
      gameStarted = true;
      document.getElementById('start-menu').style.display = 'none';
      initGame();
      requestAnimationFrame(gameLoop);
    }
    
    /***** EVENT LISTENERS *****/
    document.getElementById('play-game-btn').addEventListener('click', () => {
      document.getElementById('main-menu').style.display = 'none';
      document.getElementById('settings-menu').style.display = 'none';
      document.getElementById('mode-menu').style.display = 'block';
    });
    
    document.getElementById('classic-mode-btn').addEventListener('click', () => {
      gameMode = "classic";
      document.getElementById('mode-menu').style.display = 'none';
      document.getElementById('game-container').style.display = 'block';
    });
    
    // From Main Menu
    document.getElementById('settings-btn').addEventListener('click', () => {
      settingsOrigin = 'main';
      document.getElementById('main-menu').style.display = 'none';
      document.getElementById('settings-menu').style.display = 'block';
    });
    
    // Back button in Settings Menu.
    document.getElementById('back-btn').addEventListener('click', () => {
      document.getElementById('settings-menu').style.display = 'none';
      if (settingsOrigin === 'pause'){
        pauseMessage.style.display = 'block';
      } else {
        document.getElementById('main-menu').style.display = 'block';
      }
    });
    
    document.getElementById('start-button').addEventListener('click', startGame);
    
    // Pause Menu event listeners.
    document.getElementById('pause-btn').addEventListener('click', togglePause);
    document.getElementById('resume-btn').addEventListener('click', togglePause);
    
    // When opening settings from the pause menu, keep the game paused.
    document.getElementById('pause-settings-btn').addEventListener('click', () => {
      settingsOrigin = 'pause';
      // DO NOT change isPaused, so the game remains paused.
      pauseMessage.style.display = 'none';
      document.getElementById('settings-menu').style.display = 'block';
    });
    
    document.getElementById('pause-main-menu-btn').addEventListener('click', () => {
      isPaused = false;
      pauseMessage.style.display = 'none';
      document.getElementById('game-container').style.display = 'none';
      document.getElementById('main-menu').style.display = 'block';
    });
    
    document.addEventListener('keydown', (e) => {
      if (!gameStarted) {
        if (document.getElementById('start-menu').style.display !== 'none' && e.key === 'Enter') {
          startGame();
        }
        return;
      }
      let proposed = { x: 0, y: 0 };
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W':
          proposed.y = -GRID_SIZE;
          break;
        case 'ArrowDown': case 's': case 'S':
          proposed.y = GRID_SIZE;
          break;
        case 'ArrowLeft': case 'a': case 'A':
          proposed.x = -GRID_SIZE;
          break;
        case 'ArrowRight': case 'd': case 'D':
          proposed.x = GRID_SIZE;
          break;
        case ' ':
          if (isGameOver) {
            initGame();
            lastUpdateTime = performance.now();
            accumulatedTime = 0;
            requestAnimationFrame(gameLoop);
          } else {
            togglePause();
          }
          return;
        case 'Enter':
          if (isGameOver) {
            initGame();
            lastUpdateTime = performance.now();
            accumulatedTime = 0;
            requestAnimationFrame(gameLoop);
          }
          return;
        default:
          return;
      }
      if (proposed.x === -dx && proposed.y === -dy) return;
      if ((proposed.x !== 0 && dx !== 0) || (proposed.y !== 0 && dy !== 0)) return;
      nextDir.x = proposed.x;
      nextDir.y = proposed.y;
    });
  </script>
</body>
</html>
